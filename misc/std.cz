pub module prelude {
    pub use package::bool;
    pub use package::char;
    pub use package::i8;
    pub use package::u8;
    pub use package::i16;
    pub use package::u16;
    pub use package::i32;
    pub use package::u32;
    pub use package::i64;
    pub use package::u64;
    pub use package::i128;
    pub use package::u128;
    pub use package::isize;
    pub use package::usize;
    pub use package::f32;
    pub use package::f64;
    pub use package::string::String;

    // FIXME these are temporary, for testing
    pub unsafe fn print_bool(_ v: bool);
    pub unsafe fn print_char(_ v: char);
    pub unsafe fn print_char_hex(_ v: char);
    pub unsafe fn print_i8(_ v: i8);
    pub unsafe fn print_u8(_ v: u8);
    pub unsafe fn print_i16(_ v: i16);
    pub unsafe fn print_u16(_ v: u16);
    pub unsafe fn print_i32(_ v: i32);
    pub unsafe fn print_u32(_ v: u32);
    pub unsafe fn print_i64(_ v: i64);
    pub unsafe fn print_u64(_ v: u64);
    pub unsafe fn print_i128(_ v: i128);
    pub unsafe fn print_u128(_ v: u128);
    pub unsafe fn print_isize(_ v: isize);
    pub unsafe fn print_usize(_ v: usize);
    pub unsafe fn print_f32(_ v: f32);
    pub unsafe fn print_f64(_ v: f64);
    pub unsafe fn println();
    pub unsafe fn print_sep();
    pub unsafe fn prints(_ s: String);
    pub unsafe fn f32_to_usize(_ v: f32) -> usize;
}

pub struct f32 {{}}
pub struct f64 {{}}
pub struct i8 {{}}
pub struct u8 {{}}
pub struct i16 {{}}
pub struct u16 {{}}
pub struct i32 {{}}
pub struct u32 {{}}
pub struct i64 {{}}
pub struct u64 {{}}
pub struct i128 {{}}
pub struct u128 {{}}
pub struct isize {{}}
pub struct usize {{}}
pub struct bool {{}}
pub struct char {{}}

pub module string {
    pub struct String {
        ptr: super::ptr::Ptr<u8>,
        len: usize,
    }

    impl String {
        pub fn len(self) -> usize {
            self.len
        }
    }
}

pub module ops {
    pub struct RangeFull {}

    pub struct RangeFrom<T> {
        pub start: T,
    }

    pub struct RangeTo<T> {
        pub end: T,
    }

    pub struct Range<T> {
        pub start: T,
        pub end: T,
    }

    pub struct RangeToInclusive<T> {
        pub end: T,
    }

    pub struct RangeInclusive<T> {
        pub start: T,
        pub end: T,
    }
}

pub module ptr {
    pub struct Ptr<T> {{}}
}

module intrinsic {
    unsafe fn trap();

    unsafe fn transmute<T, U>(_ v: T) -> U;
}

pub module slice {
    struct Repr<T> {
        ptr: super::ptr::Ptr<T>,
        len: usize,
    }

    impl<T> Repr<T> {
        fn from(_ v: [T]) -> Self {
            super::intrinsic::transmute(v)
        }
    }

    impl<T> [T] {
        pub fn ptr(self) -> super::ptr::Ptr<T> {
            Repr::from(self).ptr
        }

        pub fn len(self) -> usize {
            Repr::from(self).len
        }

        fn __index_usize(self, _ i: usize) -> super::ptr::Ptr<T> {
            if i >= self.len() {
                super::intrinsic::trap();
            }
            self.ptr() + super::intrinsic::transmute<usize, isize>(i) /*FIXME*/
        }

        fn __index_range(self, _ r: super::ops::Range<usize>) -> Self {
            if r.start > r.end {
                super::intrinsic::trap();
            }
            if r.start > self.len() {
                super::intrinsic::trap();
            }
            if r.end > self.len() {
                super::intrinsic::trap();
            }
            let ptr = self.ptr() + super::intrinsic::transmute<usize, isize>(r.start) /*FIXME*/;
            let len = r.end - r.start;
            let repr = Repr { ptr: ptr, len: len };
            super::intrinsic::transmute(repr)
        }

        fn __index_range_from(self, _ r: super::ops::RangeFrom<usize>) -> Self {
            if r.start > self.len() {
                super::intrinsic::trap();
            }
            self.__index_range(r.start..self.len())
        }

        fn __index_range_full(self, _ _r: super::ops::RangeFull) -> Self {
            self
        }

        fn __index_range_inclusive(self, _ r: super::ops::RangeInclusive<usize>) -> Self {
            self.__index_range(r.start..r.end + 1)
        }

        fn __index_range_to(self, _ r: super::ops::RangeTo<usize>) -> Self {
            if r.end > self.len() {
                super::intrinsic::trap();
            }
            self.__index_range(0..r.end)
        }

        fn __index_range_to_inclusive(self, _ r: super::ops::RangeToInclusive<usize>) -> Self {
            if r.end > self.len() {
                super::intrinsic::trap();
            }
            self.__index_range(0..r.end + 1)
        }
    }
}

type Unit = {};
