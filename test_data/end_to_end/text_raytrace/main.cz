// Adapted from https://gist.github.com/joshmarinacci/c84d0979e100d107f685

pub unsafe fn sqrtf(_ v: f32) -> f32;
pub unsafe fn truncf(_ v: f32) -> f32;

module vec3 {
    struct Vec3 {
        x: f32,
        y: f32,
        z: f32,
    }

    fn new(x: f32, y: f32, z: f32) -> Vec3 {
        Vec3 { x: x, y: y, z: z }
    }

    impl Vec3 {
        fn scale(self, _ s: f32) -> Self {
            Self { x: self.x * s, y: self.y * s, z: self.z * s }
        }

        fn add(self, _ v: Self) -> Self {
            Self { x: self.x + v.x, y: self.y + v.y, z: self.z + v.z }
        }

        fn sub(self, _ v: Self) -> Self {
            Self { x: self.x - v.x, y: self.y - v.y, z: self.z - v.z }
        }

        fn dot(self, _ v: Self) -> f32 {
            self.x * v.x + self.y * v.y + self.z * v.z
        }

        fn mag(self) -> f32 {
            super::sqrtf(self.dot(self))
        }

        fn norm(self) -> Self {
            self.scale(1.0 / self.mag())
        }
    }
}

module color {
    struct Color {
        r: f32,
        g: f32,
        b: f32,
    }

    fn new(r: f32, g: f32, b: f32) -> Color {
        Color {r: r, g: g, b: b}
    }

    impl Color {
        fn scale(self, _ s: f32) -> Self {
            Self { r: self.r * s, g: self.g * s, b: self.b * s }
        }

        fn add(self, _ v: Color) -> Self {
            Self { r: self.r + v.r, g: self.g + v.g, b: self.b + v.b }
        }
    }
}

module sphere {
    use super::vec3::{self, Vec3};
    use super::color::Color;

    struct Sphere {
        center: Vec3,
        radius: f32,
        color: Color,
    }

    fn new(center: Vec3, radius: f32, color: Color) -> Sphere {
        Sphere { center: center, radius: radius, color: color }
    }

    impl Sphere {
        fn normal(self, _ pt: Vec3) -> Vec3 {
            pt.sub(self.center).norm()
        }
    }
}

struct Light {
    pos: vec3::Vec3,
    color: color::Color,
}

struct Ray {
    orig: vec3::Vec3,
    dir: vec3::Vec3,
}

fn intersect_sphere(ray: Ray, center: vec3::Vec3, radius: f32) -> {hit: bool, tval: f32} {
    let l = center.sub(ray.orig);
    let tca = l.dot(ray.dir);
    if tca >= 0.0 {
        let d2 = l.dot(l) - tca * tca;
        let r2 = radius * radius;
        if d2 <= r2 {
            let thc = sqrtf(r2 - d2);
            let t0 = tca - thc;
            //let t1 = tca + thc;
            if t0 <= 10000.0 {
                {hit: true, tval: t0}
            } else {
                {hit: false, tval: -1.0_f32}
            }
        } else {
            {hit: false, tval: -1.0_f32}
        }
    } else {
        {hit: false, tval: -1.0_f32}
    }
}

fn shade_pixel(ray: Ray, obj: sphere::Sphere, tval: f32) -> f32 {
    let WHITE   = color::new(r: 1.0, g: 1.0, b: 1.0);
    let LIGHT1 = Light {
        pos: vec3::new(x: 0.7, y: -1.0, z: 1.7),
        color: WHITE
    };

    let pi = ray.orig.add(ray.dir.scale(tval));
    let color = diffuse_shading(pi: pi, obj: obj, light: LIGHT1);
    let col = (color.r + color.g + color.b) / 3.0;
    col
}

fn clamp(_ v: f32, min: f32, max: f32) -> f32 {
    if v < min { min }
    else if v > max { max }
    else { v }
}

fn diffuse_shading(pi: vec3::Vec3, obj: sphere::Sphere, light: Light) -> color::Color {
    let n = obj.normal(pi);
    let lam1 = light.pos.sub(pi).norm().dot(n);
    let lam2 = clamp(lam1, min: 0.0, max: 1.0);
    light.color.scale(lam2 * 0.5).add(obj.color.scale(0.3))
}

fn main() {
    let RED     = color::new(r: 1.0, g: 0.0, b: 0.0);
    let GREEN   = color::new(r: 0.0, g: 1.0, b: 0.0);
    let BLUE    = color::new(r: 0.0, g: 0.0, b: 1.0);

    let SPHERE1 = sphere::new(center: vec3::new(x: -1.0, y: 0.0, z: 3.0), radius: 0.3, color: RED);
    let SPHERE2 = sphere::new(center: vec3::new(x:  0.0, y: 0.0, z: 3.0), radius: 0.8, color: GREEN);
    let SPHERE3 = sphere::new(center: vec3::new(x:  1.0, y: 0.0, z: 3.0), radius: 0.3, color: BLUE);

    let W = 20.0_f32 * 4.0;
    let H = 10.0_f32 * 4.0;

    let y = 0.0_f32;
    while y < H {
        let x = 0.0_f32;
        while x < W {
            let ray = Ray {
                orig: vec3::new(x: 0.0, y: 0.0, z: 0.0),
                dir: vec3::new(x: (x - W / 2.0) / W, y: (y - H / 2.0) / H, z: 1.0).norm(),
            };

            let hit: {obj: sphere::Sphere, tval: f32};
            let hit_found = false;

            let ret = intersect_sphere(ray: ray, center: SPHERE1.center, radius: SPHERE1.radius);
            if ret.hit {
                hit = {obj: SPHERE1, tval: ret.tval};
                hit_found = true;
            }
            let ret = intersect_sphere(ray: ray, center: SPHERE2.center, radius: SPHERE2.radius);
            if ret.hit {
                hit = {obj: SPHERE2, tval: ret.tval};
                hit_found = true;
            }
            let ret = intersect_sphere(ray: ray, center: SPHERE3.center, radius: SPHERE3.radius);
            if ret.hit {
                hit = {obj: SPHERE3, tval: ret.tval};
                hit_found = true;
            }

            let c = if hit_found {
                let shade = truncf(shade_pixel(ray: ray, obj: hit.obj, tval: hit.tval) * 5.0);
                if shade == 0.0 { '░' }
                else if shade == 1.0 { '▒' }
                else if shade == 2.0 { '▓' }
                else if shade == 3.0 { '█' }
                else if shade == 4.0 { '█' }
            } else {
                ' '
            };
            print_char(c);

            x = x + 1.0;
        }
        prints("▕"); println();
        y = y + 1.0;
    }
}