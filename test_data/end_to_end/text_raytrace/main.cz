// Adapted from https://gist.github.com/joshmarinacci/c84d0979e100d107f685

pub unsafe fn sqrtf(_ v: f32) -> f32;
pub unsafe fn truncf(_ v: f32) -> f32;

mod vec3 {
    struct Vec3 {
        x: f32,
        y: f32,
        z: f32,
    }

    fn new(x: f32, y: f32, z: f32) -> Vec3 {
        Vec3 { x: x, y: y, z: z }
    }

    fn scale(_ v: Vec3, _ s: f32) -> Vec3 {
        Vec3 { x: v.x * s, y: v.y * s, z: v.z * s }
    }

    fn add(_ a: Vec3, _ b: Vec3) -> Vec3 {
        Vec3 { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z }
    }

    fn sub(_ a: Vec3, _ b: Vec3) -> Vec3 {
        Vec3 { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }
    }

    fn dot(_ a: Vec3, _ b: Vec3) -> f32 {
        a.x * b.x + a.y * b.y + a.z * b.z
    }

    fn mag(_ v: Vec3) -> f32 {
        super::sqrtf(dot(v, v))
    }

    fn norm(_ v: Vec3) -> Vec3 {
        scale(v, 1.0 / mag(v))
    }
}

mod color {
    struct Color {
        r: f32,
        g: f32,
        b: f32,
    }

    fn new(r: f32, g: f32, b: f32) -> Color {
        Color {r: r, g: g, b: b}
    }

    fn scale(_ v: Color, _ s: f32) -> Color {
        Color { r: v.r * s, g: v.g * s, b: v.b * s }
    }

    fn add(_ a: Color, _ b: Color) -> Color {
        Color { r: a.r + b.r, g: a.g + b.g, b: a.b + b.b }
    }
}

mod sphere {
    struct Sphere {
        center: super::vec3::Vec3,
        radius: f32,
        color: super::color::Color,
    }

    fn new(center: super::vec3::Vec3, radius: f32, color: super::color::Color) -> Sphere {
        Sphere { center: center, radius: radius, color: color }
    }

    fn normal(_ v: Sphere, _ pt: super::vec3::Vec3) -> super::vec3::Vec3 {
        super::vec3::norm(super::vec3::sub(pt, v.center))
    }
}

struct Light {
    pos: vec3::Vec3,
    color: color::Color,
}

struct Ray {
    orig: vec3::Vec3,
    dir: vec3::Vec3,
}

fn intersect_sphere(ray: Ray, center: vec3::Vec3, radius: f32) -> {hit: bool, tval: f32} {
    let l = vec3::sub(center, ray.orig);
    let tca = vec3::dot(l, ray.dir);
    if tca >= 0.0 {
        let d2 = vec3::dot(l, l) - tca * tca;
        let r2 = radius * radius;
        if d2 <= r2 {
            let thc = sqrtf(r2 - d2);
            let t0 = tca - thc;
            //let t1 = tca + thc;
            if t0 <= 10000.0 {
                {hit: true, tval: t0}
            } else {
                {hit: false, tval: -1.0_f32}
            }
        } else {
            {hit: false, tval: -1.0_f32}
        }
    } else {
        {hit: false, tval: -1.0_f32}
    }
}

fn shade_pixel(ray: Ray, obj: sphere::Sphere, tval: f32) -> f32 {
    let WHITE   = color::new(r: 1.0, g: 1.0, b: 1.0);
    let LIGHT1 = Light {
        pos: vec3::new(x: 0.7, y: -1.0, z: 1.7),
        color: WHITE
    };

    let pi = vec3::add(ray.orig, vec3::scale(ray.dir, tval));
    let color = diffuse_shading(pi: pi, obj: obj, light: LIGHT1);
    let col = (color.r + color.g + color.b) / 3.0;
    col
}

fn clamp(_ v: f32, min: f32, max: f32) -> f32 {
    if v < min { min }
    else if v > max { max }
    else { v }
}

fn diffuse_shading(pi: vec3::Vec3, obj: sphere::Sphere, light: Light) -> color::Color {
    let n = sphere::normal(obj, pi);
    let lam1 = vec3::dot(vec3::norm(vec3::sub(light.pos, pi)), n);
    let lam2 = clamp(lam1, min: 0.0, max: 1.0);
    color::add(color::scale(light.color, lam2 * 0.5), color::scale(obj.color, 0.3))
}

fn main() {
    let RED     = color::new(r: 1.0, g: 0.0, b: 0.0);
    let GREEN   = color::new(r: 0.0, g: 1.0, b: 0.0);
    let BLUE    = color::new(r: 0.0, g: 0.0, b: 1.0);

    let SPHERE1 = sphere::new(center: vec3::new(x: -1.0, y: 0.0, z: 3.0), radius: 0.3, color: RED);
    let SPHERE2 = sphere::new(center: vec3::new(x:  0.0, y: 0.0, z: 3.0), radius: 0.8, color: GREEN);
    let SPHERE3 = sphere::new(center: vec3::new(x:  1.0, y: 0.0, z: 3.0), radius: 0.3, color: BLUE);

    let W = 20.0_f32 * 4.0;
    let H = 10.0_f32 * 4.0;

    let y = 0.0_f32;
    while y < H {
        let x = 0.0_f32;
        while x < W {
            let ray = Ray {
                orig: vec3::new(x: 0.0, y: 0.0, z: 0.0),
                dir: vec3::norm(vec3::new(x: (x - W / 2.0) / W, y: (y - H / 2.0) / H, z: 1.0)),
            };

            let hit: {obj: sphere::Sphere, tval: f32};
            let hit_found = false;

            let ret = intersect_sphere(ray: ray, center: SPHERE1.center, radius: SPHERE1.radius);
            if ret.hit {
                hit = {obj: SPHERE1, tval: ret.tval};
                hit_found = true;
            }
            let ret = intersect_sphere(ray: ray, center: SPHERE2.center, radius: SPHERE2.radius);
            if ret.hit {
                hit = {obj: SPHERE2, tval: ret.tval};
                hit_found = true;
            }
            let ret = intersect_sphere(ray: ray, center: SPHERE3.center, radius: SPHERE3.radius);
            if ret.hit {
                hit = {obj: SPHERE3, tval: ret.tval};
                hit_found = true;
            }

            let c = if hit_found {
                let shade = truncf(shade_pixel(ray: ray, obj: hit.obj, tval: hit.tval) * 5.0);
                if shade == 0.0 { '░' }
                else if shade == 1.0 { '▒' }
                else if shade == 2.0 { '▓' }
                else if shade == 3.0 { '█' }
                else if shade == 4.0 { '█' }
            } else {
                ' '
            };
            print_char(c);

            x = x + 1.0;
        }
        prints("▕"); println();
        y = y + 1.0;
    }
}